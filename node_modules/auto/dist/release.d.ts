import { SyncHook } from 'tapable';
import Changelog from './changelog';
import { ICreateLabelsCommandOptions } from './cli/args';
import Git from './git';
import LogParse, { IExtendedCommit } from './log-parse';
import SEMVER from './semver';
import { ILogger } from './utils/logger';
export declare type VersionLabel = SEMVER.major | SEMVER.minor | SEMVER.patch | 'skip-release' | 'release' | 'prerelease';
export declare const defaultLabels: VersionLabel[];
export declare const isVersionLabel: (label: string) => label is VersionLabel;
export interface IReleaseOptions {
    jira?: string;
    slack?: string;
    githubApi?: string;
    name?: string;
    email?: string;
    owner?: string;
    repo?: string;
    skipReleaseLabels: string[];
    onlyPublishWithReleaseLabel?: boolean;
    noVersionPrefix?: boolean;
    plugins?: (string | [string, any])[];
    labels: ILabelDefinitionMap;
}
export interface ILabelDefinition {
    name: string;
    title?: string;
    color?: string;
    description: string;
}
export interface ILabelDefinitionMap {
    [label: string]: ILabelDefinition;
}
export declare const defaultLabelDefinition: ILabelDefinitionMap;
export declare const getVersionMap: (labels?: ILabelDefinitionMap) => Map<VersionLabel, string>;
export interface IReleaseHooks {
    onCreateChangelog: SyncHook<[Changelog]>;
    onCreateLogParse: SyncHook<[LogParse]>;
}
/**
 * A class for interacting with the git remote
 */
export default class Release {
    readonly options: IReleaseOptions;
    readonly hooks: IReleaseHooks;
    private readonly git;
    private readonly logger;
    private readonly versionLabels;
    constructor(git: Git, options?: IReleaseOptions, logger?: ILogger);
    /**
     * Generate a changelog from a range of commits.
     *
     * @param from sha or tag to start changelog from
     * @param to sha or tag to end changelog at (defaults to HEAD)
     */
    generateReleaseNotes(from: string, to?: string): Promise<string>;
    getCommitsInRelease(from: string, to?: string): Promise<IExtendedCommit[]>;
    /**
     * Prepend a set of release notes to the changelog.md
     *
     * @param releaseNotes Release notes to prepend to the changelog
     * @param lastRelease Last release version of the code. Could be the first commit SHA
     * @param currentVersion Current version of the code
     * @param message Message to commit the changelog with
     */
    addToChangelog(releaseNotes: string, lastRelease: string, currentVersion: string, message?: string): Promise<void>;
    /**
     * Get a range of commits. The commits will have PR numbers and labels attached
     *
     * @param from Tag or SHA to start at
     * @param to Tage or SHA to end at (defaults to HEAD)
     */
    getCommits(from: string, to?: string): Promise<IExtendedCommit[]>;
    addLabelsToProject(labels: Partial<ILabelDefinitionMap>, options?: ICreateLabelsCommandOptions): Promise<void>;
    /**
     * Calculate the SEMVER bump over a range of commits using the PR labels
     *
     * @param from Tag or SHA to start at
     * @param to Tage or SHA to end at (defaults to HEAD)
     */
    getSemverBump(from: string, to?: string): Promise<SEMVER>;
    /**
     * Post the release notes to slack.
     *
     * @param releaseNotes Release notes to post to slack
     * @param tag Version to include in the title of the slack message
     */
    postToSlack(releaseNotes: string, tag: string): Promise<void>;
    calcNextVersion(lastTag: string): Promise<string | null>;
    private createLogParse;
    private getPRsSinceLastRelease;
    /**
     * Add the PR labels to the commit
     *
     * @param commits Commits to modify
     */
    private addLabelsToCommit;
    /**
     * Commits from rebased PRs do not have messages that tie them to a PR
     * Instead we have to find all PRs since the last release and try to match
     * their merge commit SHAs.
     *
     * @param commits Commits to modify
     */
    private getPRForRebasedCommits;
}
