"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
var set_npm_auth_token_for_ci_1 = __importDefault(require("@hutson/set-npm-auth-token-for-ci"));
var fs = __importStar(require("fs"));
var is_ci_1 = __importDefault(require("is-ci"));
var parse_author_1 = __importDefault(require("parse-author"));
var util_1 = require("util");
var get_monorepo_packages_1 = __importDefault(require("get-monorepo-packages"));
var semver_1 = require("semver");
var exec_promise_1 = __importDefault(require("../../utils/exec-promise"));
var package_config_1 = __importDefault(require("./package-config"));
var readFile = util_1.promisify(fs.readFile);
function isMonorepo() {
    return fs.existsSync('lerna.json');
}
function setTokenOnCI() {
    return __awaiter(this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            if (is_ci_1.default) {
                set_npm_auth_token_for_ci_1.default();
            }
            return [2 /*return*/];
        });
    });
}
function getPublishedVersion(name) {
    return __awaiter(this, void 0, void 0, function () {
        var error_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    return [4 /*yield*/, exec_promise_1.default('npm', ['view', name, 'version'])];
                case 1: return [2 /*return*/, _a.sent()];
                case 2:
                    error_1 = _a.sent();
                    return [2 /*return*/];
                case 3: return [2 /*return*/];
            }
        });
    });
}
function greaterRelease(prefixRelease, name, packageVersion) {
    return __awaiter(this, void 0, void 0, function () {
        var publishedVersion, publishedPrefixed;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, getPublishedVersion(name)];
                case 1:
                    publishedVersion = _a.sent();
                    if (!publishedVersion) {
                        return [2 /*return*/, packageVersion];
                    }
                    publishedPrefixed = prefixRelease(publishedVersion);
                    return [2 /*return*/, semver_1.gt(packageVersion, publishedPrefixed)
                            ? packageVersion
                            : publishedPrefixed];
            }
        });
    });
}
exports.greaterRelease = greaterRelease;
function changedPackages(sha, logger) {
    return __awaiter(this, void 0, void 0, function () {
        var packages, changedFiles;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    packages = new Set();
                    return [4 /*yield*/, exec_promise_1.default('git', [
                            'show',
                            '--first-parent',
                            sha,
                            '--name-only',
                            '--pretty='
                        ])];
                case 1:
                    changedFiles = _a.sent();
                    changedFiles.split('\n').forEach(function (filePath) {
                        var parts = filePath.split('/');
                        if (parts[0] !== 'packages' || parts.length < 3) {
                            return;
                        }
                        packages.add(parts.length > 3 && parts[1][0] === '@'
                            ? parts[1] + "/" + parts[2]
                            : parts[1]);
                    });
                    if (packages.size > 0) {
                        logger.veryVerbose.info("Got changed packages for " + sha + ":\n", packages);
                    }
                    return [2 /*return*/, __spread(packages)];
            }
        });
    });
}
exports.changedPackages = changedPackages;
function getMonorepoPackage() {
    var packages = get_monorepo_packages_1.default(process.cwd());
    return packages.reduce(function (greatest, subPackage) {
        if (subPackage.package.version) {
            if (!greatest.version) {
                return subPackage.package;
            }
            return semver_1.gt(greatest.version, subPackage.package.version)
                ? greatest
                : subPackage.package;
        }
        return greatest;
    }, {});
}
exports.getMonorepoPackage = getMonorepoPackage;
/**
 * Attempt to create a map of monorepo packages
 */
function partitionPackages(labelCommits, lineRender) {
    return __awaiter(this, void 0, void 0, function () {
        var packageCommits;
        var _this = this;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    packageCommits = {};
                    return [4 /*yield*/, Promise.all(labelCommits.map(function (commit) { return __awaiter(_this, void 0, void 0, function () {
                            var line, packages;
                            return __generator(this, function (_a) {
                                switch (_a.label) {
                                    case 0: return [4 /*yield*/, lineRender(commit)];
                                    case 1:
                                        line = _a.sent();
                                        packages = commit.packages && commit.packages.length
                                            ? commit.packages.map(function (p) { return "`" + p + "`"; }).join(', ')
                                            : 'monorepo';
                                        if (!packageCommits[packages]) {
                                            packageCommits[packages] = [];
                                        }
                                        packageCommits[packages].push(line);
                                        return [2 /*return*/];
                                }
                            });
                        }); }))];
                case 1:
                    _a.sent();
                    return [2 /*return*/, packageCommits];
            }
        });
    });
}
function bumpLatest(_a, version) {
    var localVersion = _a.version, name = _a.name;
    return __awaiter(this, void 0, void 0, function () {
        var latestVersion, _b;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    if (!localVersion) return [3 /*break*/, 2];
                    return [4 /*yield*/, greaterRelease(function (s) { return s; }, name, localVersion)];
                case 1:
                    _b = _c.sent();
                    return [3 /*break*/, 3];
                case 2:
                    _b = undefined;
                    _c.label = 3;
                case 3:
                    latestVersion = _b;
                    return [2 /*return*/, latestVersion ? semver_1.inc(latestVersion, version) : version];
            }
        });
    });
}
function loadPackageJson() {
    return __awaiter(this, void 0, void 0, function () {
        var _a, _b;
        return __generator(this, function (_c) {
            switch (_c.label) {
                case 0:
                    _b = (_a = JSON).parse;
                    return [4 /*yield*/, readFile('package.json', 'utf-8')];
                case 1: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
            }
        });
    });
}
var NPMPlugin = /** @class */ (function () {
    function NPMPlugin(config) {
        if (config === void 0) { config = {}; }
        this.name = 'NPM';
        this.setRcToken =
            typeof config.setRcToken === 'boolean' ? config.setRcToken : true;
    }
    NPMPlugin.prototype.apply = function (auto) {
        var _this = this;
        auto.hooks.beforeShipIt.tap(this.name, function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                if (!is_ci_1.default) {
                    return [2 /*return*/];
                }
                if (!process.env.NPM_TOKEN) {
                    throw new Error('NPM Token is needed for the NPM plugin!');
                }
                return [2 /*return*/];
            });
        }); });
        auto.hooks.getAuthor.tapPromise(this.name, function () { return __awaiter(_this, void 0, void 0, function () {
            var packageJson, author;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        auto.logger.verbose.info('NPM: Getting repo information from package.json');
                        return [4 /*yield*/, loadPackageJson()];
                    case 1:
                        packageJson = _a.sent();
                        if (!packageJson.author) {
                            return [2 /*return*/];
                        }
                        author = packageJson.author;
                        if (typeof author === 'string') {
                            return [2 /*return*/, parse_author_1.default(author)];
                        }
                        return [2 /*return*/, author];
                }
            });
        }); });
        auto.hooks.getPreviousVersion.tapPromise(this.name, function (prefixRelease) { return __awaiter(_this, void 0, void 0, function () {
            var previousVersion, monorepoVersion, _a, _b, _c, releasedPackage, _d, version, name, _e;
            return __generator(this, function (_f) {
                switch (_f.label) {
                    case 0:
                        previousVersion = '';
                        if (!isMonorepo()) return [3 /*break*/, 5];
                        auto.logger.veryVerbose.info('Using monorepo to calculate previous release');
                        _a = prefixRelease;
                        _c = (_b = JSON).parse;
                        return [4 /*yield*/, readFile('lerna.json', 'utf-8')];
                    case 1:
                        monorepoVersion = _a.apply(void 0, [_c.apply(_b, [_f.sent()]).version]);
                        releasedPackage = getMonorepoPackage();
                        if (!(!releasedPackage.name && !releasedPackage.version)) return [3 /*break*/, 2];
                        previousVersion = monorepoVersion;
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, greaterRelease(prefixRelease, releasedPackage.name, monorepoVersion)];
                    case 3:
                        previousVersion = _f.sent();
                        _f.label = 4;
                    case 4: return [3 /*break*/, 10];
                    case 5:
                        if (!fs.existsSync('package.json')) return [3 /*break*/, 10];
                        auto.logger.veryVerbose.info('Using package.json to calculate previous version');
                        return [4 /*yield*/, loadPackageJson()];
                    case 6:
                        _d = _f.sent(), version = _d.version, name = _d.name;
                        if (!version) return [3 /*break*/, 8];
                        return [4 /*yield*/, greaterRelease(prefixRelease, name, prefixRelease(version))];
                    case 7:
                        _e = _f.sent();
                        return [3 /*break*/, 9];
                    case 8:
                        _e = '0.0.0';
                        _f.label = 9;
                    case 9:
                        previousVersion = _e;
                        _f.label = 10;
                    case 10:
                        auto.logger.verbose.info('NPM: Got previous version from package.json', previousVersion);
                        return [2 /*return*/, previousVersion];
                }
            });
        }); });
        auto.hooks.getRepository.tapPromise(this.name, function () { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                auto.logger.verbose.info('NPM: getting repo information from package.json');
                return [2 /*return*/, package_config_1.default()];
            });
        }); });
        auto.hooks.onCreateChangelog.tap(this.name, function (changelog) { return __awaiter(_this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                changelog.hooks.renderChangelogLine.tapPromise('NPM - Monorepo', function (commits, renderLine) { return __awaiter(_this, void 0, void 0, function () {
                    var packageCommits, pkgCount, hasRepoCommits, section;
                    var _this = this;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                if (!isMonorepo()) {
                                    console.log('bailed');
                                    return [2 /*return*/];
                                }
                                return [4 /*yield*/, Promise.all(commits.map(function (commit) { return __awaiter(_this, void 0, void 0, function () {
                                        var _a;
                                        return __generator(this, function (_b) {
                                            switch (_b.label) {
                                                case 0:
                                                    _a = commit;
                                                    return [4 /*yield*/, changedPackages(commit.hash, auto.logger)];
                                                case 1:
                                                    _a.packages = _b.sent();
                                                    return [2 /*return*/];
                                            }
                                        });
                                    }); }))];
                            case 1:
                                _a.sent();
                                return [4 /*yield*/, partitionPackages(commits, renderLine)];
                            case 2:
                                packageCommits = _a.sent();
                                pkgCount = Object.keys(packageCommits).length;
                                hasRepoCommits = packageCommits.monorepo && packageCommits.monorepo.length > 0;
                                if (pkgCount <= 0 || (pkgCount === 1 && packageCommits.monorepo)) {
                                    return [2 /*return*/];
                                }
                                section = [];
                                if (hasRepoCommits) {
                                    packageCommits.monorepo.forEach(function (note) { return section.push(note); });
                                    delete packageCommits.monorepo;
                                }
                                Object.entries(packageCommits).map(function (_a) {
                                    var _b = __read(_a, 2), pkg = _b[0], lines = _b[1];
                                    section.push("- " + pkg);
                                    lines.map(function (note) { return section.push("  " + note); });
                                });
                                return [2 /*return*/, section];
                        }
                    });
                }); });
                return [2 /*return*/];
            });
        }); });
        auto.hooks.version.tapPromise(this.name, function (version) { return __awaiter(_this, void 0, void 0, function () {
            var monorepoBump, latestBump, _a;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!isMonorepo()) return [3 /*break*/, 3];
                        auto.logger.verbose.info('Detected monorepo, using lerna');
                        return [4 /*yield*/, bumpLatest(getMonorepoPackage(), version)];
                    case 1:
                        monorepoBump = _b.sent();
                        return [4 /*yield*/, exec_promise_1.default('npx', [
                                'lerna',
                                'version',
                                monorepoBump || version,
                                '--force-publish',
                                '--no-commit-hooks',
                                '--yes',
                                '-m',
                                "'Bump version to: %v [skip ci]'"
                            ])];
                    case 2:
                        _b.sent();
                        auto.logger.verbose.info('Successfully versioned repo');
                        return [2 /*return*/];
                    case 3:
                        _a = bumpLatest;
                        return [4 /*yield*/, loadPackageJson()];
                    case 4: return [4 /*yield*/, _a.apply(void 0, [_b.sent(), version])];
                    case 5:
                        latestBump = _b.sent();
                        return [4 /*yield*/, exec_promise_1.default('npm', [
                                'version',
                                latestBump || version,
                                '-m',
                                '"Bump version to: %s [skip ci]"'
                            ])];
                    case 6:
                        _b.sent();
                        auto.logger.verbose.info('Successfully versioned repo');
                        return [2 /*return*/];
                }
            });
        }); });
        auto.hooks.publish.tapPromise(this.name, function () { return __awaiter(_this, void 0, void 0, function () {
            var _a, isPrivate, name, isScopedPackage;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        if (!this.setRcToken) return [3 /*break*/, 2];
                        return [4 /*yield*/, setTokenOnCI()];
                    case 1:
                        _b.sent();
                        auto.logger.verbose.info('Set CI NPM_TOKEN');
                        _b.label = 2;
                    case 2:
                        if (!isMonorepo()) return [3 /*break*/, 6];
                        auto.logger.verbose.info('Detected monorepo, using lerna');
                        if (!(auto.args && auto.args.verbose)) return [3 /*break*/, 4];
                        return [4 /*yield*/, exec_promise_1.default('git', ['status', '--short'])];
                    case 3:
                        _b.sent();
                        _b.label = 4;
                    case 4: return [4 /*yield*/, exec_promise_1.default('npx', ['lerna', 'publish', '--yes', 'from-git'])];
                    case 5:
                        _b.sent();
                        auto.logger.verbose.info('Successfully published repo');
                        return [2 /*return*/];
                    case 6: return [4 /*yield*/, loadPackageJson()];
                    case 7:
                        _a = _b.sent(), isPrivate = _a.private, name = _a.name;
                        isScopedPackage = name.match(/@\S+\/\S+/);
                        return [4 /*yield*/, exec_promise_1.default('npm', !isPrivate && isScopedPackage
                                ? ['publish', '--access', 'public']
                                : ['publish'])];
                    case 8:
                        _b.sent();
                        return [4 /*yield*/, exec_promise_1.default('git', [
                                'push',
                                '--follow-tags',
                                '--set-upstream',
                                'origin',
                                '$branch'
                            ])];
                    case 9:
                        _b.sent();
                        auto.logger.verbose.info('Successfully published repo');
                        return [2 /*return*/];
                }
            });
        }); });
    };
    return NPMPlugin;
}());
exports.default = NPMPlugin;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi9zcmMvcGx1Z2lucy9ucG0vaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLGdHQUF5RDtBQUN6RCxxQ0FBeUI7QUFDekIsZ0RBQXlCO0FBQ3pCLDhEQUF1QztBQUN2Qyw2QkFBaUM7QUFFakMsZ0ZBQWdEO0FBQ2hELGlDQUE4QztBQUk5QywwRUFBbUQ7QUFFbkQsb0VBQXdEO0FBRXhELElBQU0sUUFBUSxHQUFHLGdCQUFTLENBQUMsRUFBRSxDQUFDLFFBQVEsQ0FBQyxDQUFDO0FBRXhDLFNBQVMsVUFBVTtJQUNqQixPQUFPLEVBQUUsQ0FBQyxVQUFVLENBQUMsWUFBWSxDQUFDLENBQUM7QUFDckMsQ0FBQztBQUVELFNBQWUsWUFBWTs7O1lBQ3pCLElBQUksZUFBSSxFQUFFO2dCQUNSLG1DQUFRLEVBQUUsQ0FBQzthQUNaOzs7O0NBQ0Y7QUFFRCxTQUFlLG1CQUFtQixDQUFDLElBQVk7Ozs7Ozs7b0JBRXBDLHFCQUFNLHNCQUFXLENBQUMsS0FBSyxFQUFFLENBQUMsTUFBTSxFQUFFLElBQUksRUFBRSxTQUFTLENBQUMsQ0FBQyxFQUFBO3dCQUExRCxzQkFBTyxTQUFtRCxFQUFDOzs7b0JBRTNELHNCQUFPOzs7OztDQUVWO0FBRUQsU0FBc0IsY0FBYyxDQUNsQyxhQUEwQyxFQUMxQyxJQUFZLEVBQ1osY0FBc0I7Ozs7O3dCQUVHLHFCQUFNLG1CQUFtQixDQUFDLElBQUksQ0FBQyxFQUFBOztvQkFBbEQsZ0JBQWdCLEdBQUcsU0FBK0I7b0JBRXhELElBQUksQ0FBQyxnQkFBZ0IsRUFBRTt3QkFDckIsc0JBQU8sY0FBYyxFQUFDO3FCQUN2QjtvQkFFSyxpQkFBaUIsR0FBRyxhQUFhLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztvQkFFMUQsc0JBQU8s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