import { AsyncParallelHook, AsyncSeriesBailHook, SyncHook, SyncWaterfallHook } from 'tapable';
import { ArgsType, IChangelogOptions, ICommentCommandOptions, ICreateLabelsCommandOptions, IInitCommandOptions, ILabelCommandOptions, IPRCheckCommandOptions, IPRCommandOptions, IReleaseCommandOptions, IShipItCommandOptions } from './cli/args';
import Changelog from './changelog';
import Git from './git';
import LogParse, { IExtendedCommit } from './log-parse';
import Release, { ILabelDefinitionMap, IReleaseOptions, VersionLabel } from './release';
import SEMVER from './semver';
import { ILogger } from './utils/logger';
interface IAuthor {
    name?: string;
    email?: string;
}
interface IRepository {
    owner?: string;
    repo?: string;
    token?: string;
}
export interface IAutoHooks {
    modifyConfig: SyncWaterfallHook<[IReleaseOptions]>;
    beforeRun: SyncHook<[IReleaseOptions]>;
    beforeShipIt: SyncHook<[]>;
    afterShipIt: AsyncParallelHook<[string | undefined, IExtendedCommit[]]>;
    afterRelease: AsyncParallelHook<[string | undefined, IExtendedCommit[]]>;
    getAuthor: AsyncSeriesBailHook<[], IAuthor | void>;
    getPreviousVersion: AsyncSeriesBailHook<[(release: string) => string], string>;
    getRepository: AsyncSeriesBailHook<[], IRepository | void>;
    onCreateRelease: SyncHook<[Release]>;
    onCreateLogParse: SyncHook<[LogParse]>;
    onCreateChangelog: SyncHook<[Changelog]>;
    version: AsyncParallelHook<[SEMVER]>;
    afterVersion: AsyncParallelHook<[]>;
    publish: AsyncParallelHook<[SEMVER]>;
    afterPublish: AsyncParallelHook<[]>;
}
export default class Auto {
    hooks: IAutoHooks;
    logger: ILogger;
    args: ArgsType;
    config?: IReleaseOptions;
    release?: Release;
    git?: Git;
    labels?: ILabelDefinitionMap;
    semVerLabels?: Map<VersionLabel, string>;
    constructor(args: ArgsType);
    /**
     * Load the .autorc from the file system, set up defaults, combine with CLI args
     * load the extends property, load the plugins and start the git remote interface.
     */
    loadConfig(): Promise<void>;
    /**
     * Interactive prompt for initializing an .autorc
     */
    init(options?: IInitCommandOptions): Promise<void>;
    /**
     * Create all of the user's labels on the git remote if the don't already exist
     *
     * @param options Options for the createLabels functionality
     */
    createLabels(options?: ICreateLabelsCommandOptions): Promise<void>;
    /**
     * Get the labels on a specific PR. Defaults to the labels of the last merged PR
     *
     * @param options Options for the createLabels functionality
     */
    label({ pr }?: ILabelCommandOptions): Promise<void>;
    /**
     * Create a status on a PR.
     *
     * @param options Options for the pr status functionality
     */
    pr({ dryRun, pr, url, ...options }: IPRCommandOptions): Promise<void>;
    /**
     * Check that a PR has a SEMVER label. Set a success status on the PR.
     *
     * @param options Options for the pr check functionality
     */
    prCheck({ dryRun, pr, url, ...options }: IPRCheckCommandOptions): Promise<void>;
    /**
     * Comment on a PR. Only one comment will be present on the PR, Older comments are removed.
     * You can use the "context" option to multiple comments on a PR.
     *
     * @param options Options for the comment functionality
     */
    comment({ message, pr, context, dryRun }: ICommentCommandOptions): Promise<void>;
    /**
     * Calculate the version bump for the current state of the repository.
     */
    version(): Promise<void>;
    /**
     * Calculate the the changelog and commit it.
     */
    changelog(options?: IChangelogOptions): Promise<void>;
    /**
     * Make a release to the git remote with the changes.
     */
    runRelease(options: IReleaseCommandOptions): Promise<void>;
    /**
     * Run the full workflow.
     *
     * 1. Calculate version
     * 2. Make changelog
     * 3. Publish code
     * 4. Create a release
     */
    shipit(options: IShipItCommandOptions): Promise<void>;
    private startGit;
    private getVersion;
    private getCurrentVersion;
    private makeChangelog;
    private makeRelease;
    private readonly prefixRelease;
    private createErrorMessage;
    /**
     * Set the git user to make releases and commit with.
     */
    private setGitUser;
    private getRepo;
    /**
     * Apply all of the plugins in the config.
     */
    private loadPlugins;
}
export {};
