"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var _a;
var fs = __importStar(require("fs"));
var semver_1 = require("semver");
var util_1 = require("util");
var typescript_memoize_1 = require("typescript-memoize");
var changelog_1 = __importDefault(require("./changelog"));
var log_parse_1 = __importDefault(require("./log-parse"));
var semver_2 = __importStar(require("./semver"));
var exec_promise_1 = __importDefault(require("./utils/exec-promise"));
var logger_1 = require("./utils/logger");
var make_hooks_1 = require("./utils/make-hooks");
var slack_1 = __importDefault(require("./utils/slack"));
exports.defaultLabels = [
    semver_2.default.major,
    semver_2.default.minor,
    semver_2.default.patch,
    'skip-release',
    'release',
    'prerelease'
];
exports.isVersionLabel = function (label) {
    return exports.defaultLabels.includes(label);
};
exports.defaultLabelDefinition = (_a = {},
    _a[semver_2.default.major] = {
        name: 'major',
        title: 'ðŸ’¥  Breaking Change',
        description: 'Increment the major version when merged'
    },
    _a[semver_2.default.minor] = {
        name: 'minor',
        title: 'ðŸš€  Enhancement',
        description: 'Increment the minor version when merged'
    },
    _a[semver_2.default.patch] = {
        name: 'patch',
        title: 'ðŸ›  Bug Fix',
        description: 'Increment the patch version when merged'
    },
    _a['skip-release'] = {
        name: 'skip-release',
        description: 'Preserve the current version when merged'
    },
    _a.release = {
        name: 'release',
        description: 'Create a release when this pr is merged'
    },
    _a.prerelease = {
        name: 'prerelease',
        title: 'ðŸš§ Prerelease',
        description: 'Create a pre-release version when merged'
    },
    _a.internal = {
        name: 'internal',
        title: 'ðŸ   Internal',
        description: 'Changes only affect the internal API'
    },
    _a.documentation = {
        name: 'documentation',
        title: 'ðŸ“  Documentation',
        description: 'Changes only affect the documentation'
    },
    _a);
exports.getVersionMap = function (labels) {
    if (labels === void 0) { labels = exports.defaultLabelDefinition; }
    return Object.entries(labels).reduce(function (semVer, _a) {
        var _b = __read(_a, 2), label = _b[0], labelDef = _b[1];
        if (exports.isVersionLabel(label)) {
            semVer.set(label, labelDef.name);
        }
        return semVer;
        // tslint:disable-next-line align
    }, new Map());
};
var readFile = util_1.promisify(fs.readFile);
var writeFile = util_1.promisify(fs.writeFile);
/**
 * A class for interacting with the git remote
 */
var Release = /** @class */ (function () {
    function Release(git, options, logger) {
        if (options === void 0) { options = {
            skipReleaseLabels: [],
            labels: exports.defaultLabelDefinition
        }; }
        if (logger === void 0) { logger = logger_1.dummyLog(); }
        this.options = options;
        this.logger = logger;
        this.hooks = make_hooks_1.makeReleaseHooks();
        this.versionLabels = exports.getVersionMap(options.labels);
        this.git = git;
    }
    /**
     * Generate a changelog from a range of commits.
     *
     * @param from sha or tag to start changelog from
     * @param to sha or tag to end changelog at (defaults to HEAD)
     */
    Release.prototype.generateReleaseNotes = function (from, to) {
        if (to === void 0) { to = 'HEAD'; }
        return __awaiter(this, void 0, void 0, function () {
            var commits, project, changelog;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getCommitsInRelease(from, to)];
                    case 1:
                        commits = _a.sent();
                        return [4 /*yield*/, this.git.getProject()];
                    case 2:
                        project = _a.sent();
                        changelog = new changelog_1.default(this.logger, {
                            owner: this.git.options.owner,
                            repo: this.git.options.repo,
                            baseUrl: project.html_url,
                            jira: this.options.jira,
                            labels: this.options.labels
                        });
                        this.hooks.onCreateChangelog.call(changelog);
                        changelog.loadDefaultHooks();
                        return [2 /*return*/, changelog.generateReleaseNotes(commits)];
                }
            });
        });
    };
    Release.prototype.getCommitsInRelease = function (from, to) {
        if (to === void 0) { to = 'HEAD'; }
        return __awaiter(this, void 0, void 0, function () {
            var allCommits, allPrCommits, allPrCommitHashes;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getCommits(from, to)];
                    case 1:
                        allCommits = _a.sent();
                        return [4 /*yield*/, Promise.all(allCommits
                                .filter(function (commit) { return commit.pullRequest; })
                                .map(function (commit) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                return [2 /*return*/, this.git.getCommitsForPR(Number(commit.pullRequest.number))];
                            }); }); }))];
                    case 2:
                        allPrCommits = _a.sent();
                        allPrCommitHashes = allPrCommits
                            .filter(Boolean)
                            .reduce(function (all, pr) { return __spread(all, pr.map(function (subCommit) { return subCommit.sha; })); }, []);
                        return [2 /*return*/, allCommits
                                .filter(function (commit) {
                                return !allPrCommitHashes.includes(commit.hash) &&
                                    !commit.subject.includes('[skip ci]');
                            })
                                .map(function (commit) {
                                if (commit.pullRequest) {
                                    return commit;
                                }
                                commit.labels = __spread(['pushToMaster'], commit.labels);
                                commit.subject = commit.subject.split('\n')[0];
                                return commit;
                            })];
                }
            });
        });
    };
    /**
     * Prepend a set of release notes to the changelog.md
     *
     * @param releaseNotes Release notes to prepend to the changelog
     * @param lastRelease Last release version of the code. Could be the first commit SHA
     * @param currentVersion Current version of the code
     * @param message Message to commit the changelog with
     */
    Release.prototype.addToChangelog = function (releaseNotes, lastRelease, currentVersion, message) {
        if (message === void 0) { message = 'Update CHANGELOG.md [skip ci]'; }
        return __awaiter(this, void 0, void 0, function () {
            var version, bump, date, prefixed, newChangelog, oldChangelog;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.logger.verbose.info('Adding new changes to changelog.');
                        if (!lastRelease.match(/\d+\.\d+\.\d+/)) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.calcNextVersion(lastRelease)];
                    case 1:
                        version = _a.sent();
                        return [3 /*break*/, 4];
                    case 2: return [4 /*yield*/, this.getSemverBump(lastRelease)];
                    case 3:
                        bump = _a.sent();
                        version = semver_1.inc(currentVersion, bump);
                        _a.label = 4;
                    case 4:
                        this.logger.verbose.info('Calculated next version to be:', version);
                        date = new Date().toDateString();
                        prefixed = this.options.noVersionPrefix || (version && version.startsWith('v'))
                            ? version
                            : "v" + version;
                        newChangelog = "# " + prefixed + " (" + date + ")\n\n" + releaseNotes;
                        if (!fs.existsSync('CHANGELOG.md')) return [3 /*break*/, 6];
                        this.logger.verbose.info('Old changelog exists, prepending changes.');
                        return [4 /*yield*/, readFile('CHANGELOG.md', 'utf8')];
                    case 5:
                        oldChangelog = _a.sent();
                        newChangelog = newChangelog + "\n\n---\n\n" + oldChangelog;
                        _a.label = 6;
                    case 6: return [4 /*yield*/, writeFile('CHANGELOG.md', newChangelog)];
                    case 7:
                        _a.sent();
                        this.logger.verbose.info('Wrote new changelog to filesystem.');
                        return [4 /*yield*/, exec_promise_1.default('git', ['add', 'CHANGELOG.md'])];
                    case 8:
                        _a.sent();
                        return [4 /*yield*/, exec_promise_1.default('git', ['commit', '-m', "\"" + message + "\"", '--no-verify'])];
                    case 9:
                        _a.sent();
                        this.logger.verbose.info('Commited new changelog.');
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Get a range of commits. The commits will have PR numbers and labels attached
     *
     * @param from Tag or SHA to start at
     * @param to Tage or SHA to end at (defaults to HEAD)
     */
    Release.prototype.getCommits = function (from, to) {
        if (to === void 0) { to = 'HEAD'; }
        return __awaiter(this, void 0, void 0, function () {
            var gitlog, logParse, commits;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        this.logger.verbose.info("Getting commits from " + from + " to " + to);
                        return [4 /*yield*/, this.git.getGitLog(from, to)];
                    case 1:
                        gitlog = _a.sent();
                        this.logger.veryVerbose.info('Got gitlog:\n', gitlog);
                        return [4 /*yield*/, this.createLogParse()];
                    case 2:
                        logParse = _a.sent();
                        return [4 /*yield*/, logParse.normalizeCommits(gitlog)];
                    case 3:
                        commits = _a.sent();
                        this.logger.veryVerbose.info('Added labels to commits:\n', commits);
                        return [4 /*yield*/, Promise.all(commits.map(function (commit) { return __awaiter(_this, void 0, void 0, function () {
                                var resolvedAuthors, prCommits, author;
                                var _this = this;
                                return __generator(this, function (_a) {
                                    switch (_a.label) {
                                        case 0:
                                            resolvedAuthors = [];
                                            if (!commit.pullRequest) return [3 /*break*/, 3];
                                            return [4 /*yield*/, this.git.getCommitsForPR(Number(commit.pullRequest.number))];
                                        case 1:
                                            prCommits = _a.sent();
                                            if (!prCommits) {
                                                return [2 /*return*/];
                                            }
                                            return [4 /*yield*/, Promise.all(prCommits.map(function (prCommit) { return __awaiter(_this, void 0, void 0, function () {
                                                    return __generator(this, function (_a) {
                                                        if (prCommit && prCommit.author) {
                                                            return [2 /*return*/, this.git.getUserByUsername(prCommit.author.login)];
                                                        }
                                                        return [2 /*return*/];
                                                    });
                                                }); }))];
                                        case 2:
                                            resolvedAuthors = _a.sent();
                                            return [3 /*break*/, 5];
                                        case 3:
                                            if (!commit.authorEmail) return [3 /*break*/, 5];
                                            return [4 /*yield*/, this.git.getUserByEmail(commit.authorEmail)];
                                        case 4:
                                            author = _a.sent();
                                            resolvedAuthors.push(author);
                                            _a.label = 5;
                                        case 5:
                                            commit.authors = resolvedAuthors.map(function (author) { return (__assign({}, author, { username: author ? author.login : undefined })); });
                                            commit.authors.map(function (author) {
                                                _this.logger.veryVerbose.info("Found author: " + author.username);
                                            });
                                            return [2 /*return*/];
                                    }
                                });
                            }); }))];
                    case 4:
                        _a.sent();
                        return [2 /*return*/, commits];
                }
            });
        });
    };
    Release.prototype.addLabelsToProject = function (labels, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var oldLabels, labelsToCreate, repoMetadata, justLabelNames, state, state;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.git.getProjectLabels()];
                    case 1:
                        oldLabels = _a.sent();
                        labelsToCreate = Object.entries(labels).filter(function (_a) {
                            var _b = __read(_a, 2), versionLabel = _b[0], labelDef = _b[1];
                            if (!labelDef) {
                                return;
                            }
                            if (versionLabel === 'release' &&
                                !_this.options.onlyPublishWithReleaseLabel) {
                                return;
                            }
                            if (versionLabel === 'skip-release' &&
                                _this.options.onlyPublishWithReleaseLabel) {
                                return;
                            }
                            return true;
                        });
                        if (!!options.dryRun) return [3 /*break*/, 3];
                        return [4 /*yield*/, Promise.all(labelsToCreate.map(function (_a) {
                                var _b = __read(_a, 2), label = _b[0], labelDef = _b[1];
                                return __awaiter(_this, void 0, void 0, function () {
                                    return __generator(this, function (_c) {
                                        switch (_c.label) {
                                            case 0:
                                                if (!labelDef) {
                                                    return [2 /*return*/];
                                                }
                                                if (!(oldLabels && oldLabels.includes(labelDef.name))) return [3 /*break*/, 2];
                                                return [4 /*yield*/, this.git.updateLabel(label, labelDef)];
                                            case 1:
                                                _c.sent();
                                                return [3 /*break*/, 4];
                                            case 2: return [4 /*yield*/, this.git.createLabel(label, labelDef)];
                                            case 3:
                                                _c.sent();
                                                _c.label = 4;
                                            case 4: return [2 /*return*/];
                                        }
                                    });
                                });
                            }))];
                    case 2:
                        _a.sent();
                        _a.label = 3;
                    case 3: return [4 /*yield*/, this.git.getProject()];
                    case 4:
                        repoMetadata = _a.sent();
                        justLabelNames = labelsToCreate.map(function (_a) {
                            var _b = __read(_a, 1), name = _b[0];
                            return name;
                        });
                        if (justLabelNames.length > 0) {
                            state = options.dryRun ? 'Would have created' : 'Created';
                            this.logger.log.log(state + " labels: " + justLabelNames.join(', '));
                        }
                        else {
                            state = options.dryRun ? 'would have been' : 'were';
                            this.logger.log.log("No labels " + state + " created, they must have already been present on your project.");
                        }
                        if (options.dryRun) {
                            return [2 /*return*/];
                        }
                        this.logger.log.log("\nYou can see these, and more at " + repoMetadata.html_url + "/labels");
                        return [2 /*return*/];
                }
            });
        });
    };
    /**
     * Calculate the SEMVER bump over a range of commits using the PR labels
     *
     * @param from Tag or SHA to start at
     * @param to Tage or SHA to end at (defaults to HEAD)
     */
    Release.prototype.getSemverBump = function (from, to) {
        if (to === void 0) { to = 'HEAD'; }
        return __awaiter(this, void 0, void 0, function () {
            var commits, labels, _a, onlyPublishWithReleaseLabel, skipReleaseLabels, options, result;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0: return [4 /*yield*/, this.getCommits(from, to)];
                    case 1:
                        commits = _b.sent();
                        labels = commits.map(function (commit) { return commit.labels; });
                        _a = this.options, onlyPublishWithReleaseLabel = _a.onlyPublishWithReleaseLabel, skipReleaseLabels = _a.skipReleaseLabels;
                        options = { onlyPublishWithReleaseLabel: onlyPublishWithReleaseLabel, skipReleaseLabels: skipReleaseLabels };
                        this.logger.verbose.info('Calculating SEMVER bump using:\n', {
                            labels: labels,
                            versionLabels: this.versionLabels,
                            options: options
                        });
                        result = semver_2.calculateSemVerBump(labels, this.versionLabels, options);
                        this.logger.verbose.success('Calculated SEMVER bump:', result);
                        return [2 /*return*/, result];
                }
            });
        });
    };
    /**
     * Post the release notes to slack.
     *
     * @param releaseNotes Release notes to post to slack
     * @param tag Version to include in the title of the slack message
     */
    Release.prototype.postToSlack = function (releaseNotes, tag) {
        return __awaiter(this, void 0, void 0, function () {
            var project;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!this.options.slack) {
                            throw new Error('Slack url must be set to post a message to slack.');
                        }
                        return [4 /*yield*/, this.git.getProject()];
                    case 1:
                        project = _a.sent();
                        this.logger.verbose.info('Posting release notes to slack.');
                        return [4 /*yield*/, slack_1.default(releaseNotes, {
                                tag: tag,
                                owner: this.git.options.owner,
                                repo: this.git.options.repo,
                                baseUrl: project.html_url,
                                slackUrl: this.options.slack
                            })];
                    case 2:
                        _a.sent();
                        this.logger.verbose.info('Posted release notes to slack.');
                        return [2 /*return*/];
                }
            });
        });
    };
    Release.prototype.calcNextVersion = function (lastTag) {
        return __awaiter(this, void 0, void 0, function () {
            var bump;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, this.getSemverBump(lastTag)];
                    case 1:
                        bump = _a.sent();
                        return [2 /*return*/, semver_1.inc(lastTag, bump)];
                }
            });
        });
    };
    Release.prototype.createLogParse = function () {
        return __awaiter(this, void 0, void 0, function () {
            var logParse;
            var _this = this;
            return __generator(this, function (_a) {
                logParse = new log_parse_1.default();
                logParse.hooks.parseCommit.tapPromise('Labels', function (commit) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                    return [2 /*return*/, this.addLabelsToCommit(commit)];
                }); }); });
                logParse.hooks.parseCommit.tapPromise('PR Commits', function (commit) { return __awaiter(_this, void 0, void 0, function () {
                    var prsSinceLastRelease;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.getPRsSinceLastRelease()];
                            case 1:
                                prsSinceLastRelease = _a.sent();
                                return [2 /*return*/, this.getPRForRebasedCommits(commit, prsSinceLastRelease)];
                        }
                    });
                }); });
                this.hooks.onCreateLogParse.call(logParse);
                return [2 /*return*/, logParse];
            });
        });
    };
    Release.prototype.getPRsSinceLastRelease = function () {
        return __awaiter(this, void 0, void 0, function () {
            var lastRelease, error_1, firstCommit, _a, prsSinceLastRelease, data;
            var _this = this;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        _b.trys.push([0, 2, , 5]);
                        return [4 /*yield*/, this.git.getLatestReleaseInfo()];
                    case 1:
                        lastRelease = _b.sent();
                        return [3 /*break*/, 5];
                    case 2:
                        error_1 = _b.sent();
                        return [4 /*yield*/, this.git.getFirstCommit()];
                    case 3:
                        firstCommit = _b.sent();
                        _a = {};
                        return [4 /*yield*/, this.git.getCommitDate(firstCommit)];
                    case 4:
                        lastRelease = (_a.published_at = _b.sent(),
                            _a);
                        return [3 /*break*/, 5];
                    case 5:
                        if (!lastRelease) {
                            return [2 /*return*/, []];
                        }
                        return [4 /*yield*/, this.git.searchRepo({
                                q: "is:pr is:merged merged:>=" + lastRelease.published_at
                            })];
                    case 6:
                        prsSinceLastRelease = _b.sent();
                        if (!prsSinceLastRelease || !prsSinceLastRelease.items) {
                            return [2 /*return*/, []];
                        }
                        return [4 /*yield*/, Promise.all(prsSinceLastRelease.items.map(function (pr) { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                                return [2 /*return*/, this.git.getPullRequest(Number(pr.number))];
                            }); }); }))];
                    case 7:
                        data = _b.sent();
                        return [2 /*return*/, data.map(function (item) { return item.data; })];
                }
            });
        });
    };
    /**
     * Add the PR labels to the commit
     *
     * @param commits Commits to modify
     */
    Release.prototype.addLabelsToCommit = function (commit) {
        return __awaiter(this, void 0, void 0, function () {
            var labels;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!commit.labels) {
                            commit.labels = [];
                        }
                        if (!commit.pullRequest) return [3 /*break*/, 2];
                        return [4 /*yield*/, this.git.getLabels(commit.pullRequest.number)];
                    case 1:
                        labels = (_a.sent()) || [];
                        commit.labels = __spread(labels, commit.labels);
                        _a.label = 2;
                    case 2: return [2 /*return*/, commit];
                }
            });
        });
    };
    /**
     * Commits from rebased PRs do not have messages that tie them to a PR
     * Instead we have to find all PRs since the last release and try to match
     * their merge commit SHAs.
     *
     * @param commits Commits to modify
     */
    Release.prototype.getPRForRebasedCommits = function (commit, pullRequests) {
        var matchPr = pullRequests.find(function (pr) { return pr.merge_commit_sha === commit.hash; });
        if (!commit.pullRequest && matchPr) {
            var labels = matchPr.labels.map(function (label) { return label.name; }) || [];
            commit.labels = __spread(labels, commit.labels);
            commit.pullRequest = {
                number: matchPr.number
            };
        }
        return commit;
    };
    __decorate([
        typescript_memoize_1.Memoize()
    ], Release.prototype, "createLogParse", null);
    __decorate([
        typescript_memoize_1.Memoize()
    ], Release.prototype, "getPRsSinceLastRelease", null);
    return Release;
}());
exports.default = Release;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVsZWFzZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9yZWxlYXNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxxQ0FBeUI7QUFDekIsaUNBQTBDO0FBQzFDLDZCQUFpQztBQUdqQyx5REFBNkM7QUFDN0MsMERBQW9DO0FBR3BDLDBEQUF3RDtBQUN4RCxpREFBdUQ7QUFDdkQsc0VBQStDO0FBQy9DLHlDQUFtRDtBQUNuRCxpREFBc0Q7QUFDdEQsd0RBQXdDO0FBVTNCLFFBQUEsYUFBYSxHQUFtQjtJQUMzQyxnQkFBTSxDQUFDLEtBQUs7SUFDWixnQkFBTSxDQUFDLEtBQUs7SUFDWixnQkFBTSxDQUFDLEtBQUs7SUFDWixjQUFjO0lBQ2QsU0FBUztJQUNULFlBQVk7Q0FDYixDQUFDO0FBRVcsUUFBQSxjQUFjLEdBQUcsVUFBQyxLQUFhO0lBQzFDLE9BQUEscUJBQWEsQ0FBQyxRQUFRLENBQUMsS0FBcUIsQ0FBQztBQUE3QyxDQUE2QyxDQUFDO0FBNEJuQyxRQUFBLHNCQUFzQjtJQUNqQyxHQUFDLGdCQUFNLENBQUMsS0FBSyxJQUFHO1FBQ2QsSUFBSSxFQUFFLE9BQU87UUFDYixLQUFLLEVBQUUscUJBQXFCO1FBQzVCLFdBQVcsRUFBRSx5Q0FBeUM7S0FDdkQ7SUFDRCxHQUFDLGdCQUFNLENBQUMsS0FBSyxJQUFHO1FBQ2QsSUFBSSxFQUFFLE9BQU87UUFDYixLQUFLLEVBQUUsaUJBQWlCO1FBQ3hCLFdBQVcsRUFBRSx5Q0FBeUM7S0FDdkQ7SUFDRCxHQUFDLGdCQUFNLENBQUMsS0FBSyxJQUFHO1FBQ2QsSUFBSSxFQUFFLE9BQU87UUFDYixLQUFLLEVBQUUsYUFBYTtRQUNwQixXQUFXLEVBQUUseUNBQXlDO0tBQ3ZEO0lBQ0Qsa0JBQWMsR0FBRTtRQUNkLElBQUksRUFB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